import type { paths } from "@generated/weather-api/fetch-client"; // generated by openapi-typescript

import createClient from "openapi-fetch";

import {
	pointsResponseSchema,
	type StationsResponse,
	stationsResponseSchema,
} from "./weather.validators";

export const WEATHER_BASE_URL = "https://api.weather.gov";

export const weatherClient = createClient<paths>({
	baseUrl: WEATHER_BASE_URL,
});

export async function fetchWeatherStation({
	latitude,
	longitude,
}: {
	latitude: number;
	longitude: number;
}): Promise<{
	stationProperties: StationsResponse["features"][number]["properties"] | null;
	gridCoordinates: {
		gridId: string;
		gridX: number;
		gridY: number;
	} | null;
} | null> {
	try {
		const pointsResponse = await weatherClient.GET(
			"/points/{latitude},{longitude}",
			{
				params: {
					path: {
						latitude,
						longitude,
					},
				},
			},
		);

		if (pointsResponse.error) {
			console.error("Failed to fetch weather stations:", pointsResponse.error);
			return null;
		}

		if (!pointsResponse.data) {
			console.error("No weather station data returned");
			return null;
		}

		const pointData = pointsResponseSchema.parse(pointsResponse.data);

		const gridCoordinates = {
			gridId: pointData.properties.gridId,
			gridX: pointData.properties.gridX,
			gridY: pointData.properties.gridY,
		};

		const stationResponse = await weatherClient.GET(
			"/gridpoints/{wfo}/{x},{y}/stations",
			{
				params: {
					path: {
						wfo: pointData.properties.gridId,
						x: pointData.properties.gridX,
						y: pointData.properties.gridY,
					},
				},
			},
		);

		if (stationResponse.error) {
			console.error(stationResponse.error.title);
			return null;
		}

		const stationsData = stationsResponseSchema.parse(stationResponse.data);
		const features = stationsData?.features ?? [];

		// The spec implies logic to "Pick first station (closest)"
		// The NWS API typically orders stations by proximity for spatial queries,
		// so the first element is usually the closest.
		const firstStation = features[0];

		if (!firstStation) {
			console.error("No weather stations available for this location");
			return null;
		}

		return {
			stationProperties: firstStation.properties,
			gridCoordinates,
		};
	} catch (error) {
		console.error("Error fetching weather station:", error);
		return null;
	}
}

// The API is organized into these main endpoint groups:
// 1. Alerts - /alerts* (8 endpoints) - Severe weather warnings
// 2. Aviation - /aviation/* (7 endpoints) - CWUs and SIGMETs
// 3. Points - /points/{lat},{lon}* (3 endpoints) - Location-based weather lookup
// 4. Gridpoints - /gridpoints/{wfo},{x},{y}* (4 endpoints) - Detailed forecasts
// 5. Stations - /stations* (7 endpoints) - Weather station data & observations
// 6. Offices - /offices* (3 endpoints) - NWS forecast office info
// 7. Products - /products* (8 endpoints) - Text weather products
// 8. Radar - /radar/* (6 endpoints) - Radar server/station info
// 9. Zones - /zones/* (5 endpoints) - Weather zone forecasts
// 10. Icons - /icons* (4 endpoints) - Weather icons
// 11. Glossary - /glossary - Terminology
// 12. Thumbnails - /thumbnails/satellite/* - Satellite images
// For a travel anchor app, I'd assume you need:
// - /points/* (location lookup)
// - /gridpoints/{wfo},{x},{y}/forecast* (forecasts)
// - /alerts/active* (weather warnings)
// - /stations/{stationId}/observations/latest (current conditions)
// The weather data I actually need for your application is the location lookup in order to find the stationId. From there I want /stations/{stationId}/observations/latest & /alerts/active*
